) %>%
left_join(n_estudos_obs, by = "Variavel") %>%
mutate(
studlab = paste0(Variavel, " (n = ", N_estudos, ", obs = ", N_obs, ")"),
p_value_fmt = ifelse(is.na(p_value), "NA", sprintf("%.3f", p_value))
)
# 7. Meta-an√°lise agregada
meta_final <- metagen(
TE = resumo_vars$TE,
seTE = resumo_vars$seTE,
studlab = resumo_vars$studlab,
sm = "SMD (Hedges)",
method.tau = "DL",
common = FALSE,
random = TRUE
)
# 8. Forest plot
forest(
meta_final,
comb.fixed = FALSE,
comb.random = TRUE,
overall = TRUE,
print.heterogeneity = FALSE,
print.Q = FALSE,
print.I2 = FALSE,
print.tau2 = FALSE,
col.square = "blue",
col.diamond = "darkgreen",
digits = 3,
digits.TE = 3,
at = seq(-2, 2, by = 0.5),
xlab = "D de Hedges (SMD)",
rightcols = c("effect", "ci", "w.random", "pval"),
rightlabs = c("g", "IC 95%", "Peso (%)", "p-valor"),
leftcols = c("studlab"),
leftlabs = c("Vari√°veis f√≠sicas (n, obs)")
)
# 9. Tabela
resumo_global <- tibble(
`Indicadores funcionais (n, obs)` = "Modelo Global",
`D de Hedges` = round(meta_final$TE.random, 3) %>% as.character(),
`IC 95%` = paste0("[", round(meta_final$lower.random, 3), "; ", round(meta_final$upper.random, 3), "]"),
`Peso (%)` = "",
`p-valor` = sprintf("%.3f", meta_final$pval.random)
)
tabela_variaveis <- tibble(
`Indicadores funcionais (n, obs)` = meta_final$studlab,
`D de Hedges` = round(meta_final$TE, 3) %>% as.character(),
`IC 95%` = paste0("[", round(meta_final$lower, 3), "; ", round(meta_final$upper, 3), "]"),
`Peso (%)` = round(100 * meta_final$w.random / sum(meta_final$w.random), 1) %>% as.character(),
`p-valor` = sprintf("%.3f", meta_final$pval)
)
tabela_final <- bind_rows(resumo_global, tabela_variaveis)
# 10. Legenda estat√≠stica
caption_fisico <- paste0(
"Resumo da Meta-An√°lise com Modelo de Efeito Aleat√≥rio\n",
"Q(", meta_final$k - 1, ") = ", round(meta_final$Q, 2), ", ",
"p(Q) = ", sprintf("%.3f", meta_final$pval.Q), ", ",
"Tau¬≤ = ", round(meta_final$tau2, 3), ", ",
"I¬≤ = ", round(meta_final$I2, 1), "%"
)
nota_explicativa <- "Nota: (n) refere-se ao n√∫mero de estudos independentes inclu√≠dos para cada indicador funcional do solo, enquanto (obs) representa o n√∫mero total de observa√ß√µes, considerando combina√ß√µes espec√≠ficas entre estudos e vari√°veis."
# 11. Tabela formatada
kable(
tabela_final,
align = c("l", "r", "c", "r", "r"),
caption = caption_fisico,
col.names = c("Indicadores funcionais (n, obs)", "D de Hedges", "IC 95%", "Peso (%)", "p-valor")
) %>%
kable_styling(bootstrap_options = "striped", full_width = FALSE) %>%
add_footnote(nota_explicativa, notation = "none")
# 12. Funnel plot
funnel(
meta_final,
main = "Funnel plot - Indicadores F√≠sicos do Solo",
xlab = "D de Hedges (SMD)",
ylab = "Erro padr√£o",
pch = 19,
col = "blue",
contour = TRUE,
contour.levels = c(0.90, 0.95, 0.99),
col.contour = c("gray90", "gray80", "gray70"),
legend = TRUE,
back = TRUE
)
# 11. Tabela formatada
kable(
tabela_final,
align = c("l", "r", "c", "r", "r"),
caption = caption_fisico,
col.names = c("Indicadores funcionais (n, obs)", "D de Hedges", "IC 95%", "Peso (%)", "p-valor")
) %>%
kable_styling(bootstrap_options = "striped", full_width = FALSE) %>%
add_footnote(nota_explicativa, notation = "none")
rm(list = ls()); gc()
# 1. Ler base de dados
dados <- read_excel("C:/Users/vidal/OneDrive/Documentos/ARTIGO_MA/3 - DADOS/bd.xlsx", sheet = "MANEJO") %>%
mutate(across(c(m_e, sd_e, n_e, m_c, sd_c, n_c), ~ as.numeric(gsub(",", ".", gsub("[^0-9,.-]", "", as.character(.))))),
Variavel = factor(Variavel))
# 2. Imputa√ß√£o m√∫ltipla via CART
dados_imput <- mice(dados, m = 5, method = "cart", seed = 10)
# 3. Calcular lnRR e vari√¢ncia
dados_completos <- complete(dados_imput, action = "long", include = TRUE) %>%
filter(m_e > 0, m_c > 0) %>%
mutate(
lnRR = log(m_e / m_c),
vi = (sd_e^2 / (n_e * m_e^2)) + (sd_c^2 / (n_c * m_c^2))
) %>%
filter(!is.na(vi), !is.infinite(vi), vi > 0, vi < quantile(vi, 0.999, na.rm = TRUE))
# 4. Meta-an√°lises por imputa√ß√£o
resultados_rubin <- future_lapply(1:5, function(i) {
dados_i <- complete(dados_imput, i)
if (!"Variavel" %in% names(dados_i)) return(NULL)
var_levels <- unique(dados_i$Variavel)
map_dfr(var_levels, function(v) {
df <- filter(dados_i, Variavel == v)
if (nrow(df) == 0) return(NULL)
meta <- tryCatch(
metacont(
n.e = n_e, mean.e = m_e, sd.e = sd_e,
n.c = n_c, mean.c = m_c, sd.c = sd_c,
studlab = Study, sm = "SMD", method.smd = "Hedges",
method.tau = "REML", common = FALSE, data = df
),
error = function(e) NULL
)
if (is.null(meta)) return(NULL)
tibble(
.imp = i,
Variavel = v,
TE = meta$TE.random,
seTE = meta$seTE.random
)
})
}) %>% bind_rows()
# 5. Contagem de estudos
n_estudos_obs <- dados_completos %>%
group_by(Variavel) %>%
summarise(N_estudos = n_distinct(Study), N_obs = n(), .groups = "drop")
# 6. Combina√ß√£o por Rubin
resumo_vars <- resultados_rubin %>%
group_by(Variavel) %>%
summarise(
TE = mean(TE, na.rm = TRUE),
W = mean(seTE^2, na.rm = TRUE),
B = var(TE, na.rm = TRUE),
T_var = ifelse(is.na(B), W, W + (1 + 1/5) * B),
seTE = sqrt(T_var),
df = ifelse(is.na(B) || B == 0, Inf, (5 - 1) * (1 + W / ((1 + 1/5) * B))^2),
IC_inf = TE - qt(0.975, df) * seTE,
IC_sup = TE + qt(0.975, df) * seTE,
p_value = ifelse(is.infinite(df), 2 * pnorm(-abs(TE / seTE)), 2 * pt(-abs(TE / seTE), df)),
.groups = "drop"
) %>%
left_join(n_estudos_obs, by = "Variavel")
# 7. Classifica√ß√£o das vari√°veis por grupo funcional
mapa_grupos <- tibble(
Variavel_original = unique(as.character(resumo_vars$Variavel))
) %>%
mutate(
Variavel_padrao = toupper(gsub("[^A-Za-z]", "", Variavel_original)),
Grupo_temp = case_when(
# Qu√≠mico
Variavel_padrao %in% c("SOILORGANICCARBONSOC", "SOC") ~ "Qu√≠mico",
Variavel_padrao %in% c("SOILPH", "PH") ~ "Qu√≠mico",
Variavel_padrao %in% c("TOTALNITROGENTN", "TN") ~ "Qu√≠mico",
Variavel_padrao %in% c("AVAILABLETOTALPHOSPHORUSATP", "ATP") ~ "Qu√≠mico",
Variavel_padrao %in% c("AVAILABLEPOTASSIUMAK", "AK") ~ "Qu√≠mico",
Variavel_padrao %in% c("AVAILABLEMAGNESIUMAMG", "AMG") ~ "Qu√≠mico",
# F√≠sico
Variavel_padrao %in% c("SOILBULKDENSITYPB", "SOILBULKDENSITY", "BULKDENSITY", "PB") ~ "F√≠sico",
Variavel_padrao %in% c("PLANTAVAILABLEWATERCAPACITYPAWC", "PAWC") ~ "F√≠sico",
Variavel_padrao %in% c("MACROPOROSITYEMACRO", "MACROPOROSITYMACRO", "EMACRO") ~ "F√≠sico",
Variavel_padrao %in% c("PENETRATIONRESISTANCEPR", "PR") ~ "F√≠sico",
Variavel_padrao %in% c("WATERSTABLEAGGREGATESWSA", "WSA") ~ "F√≠sico",
Variavel_padrao %in% c("RUNOFFQ", "Q") ~ "F√≠sico",
Variavel_padrao %in% c("EROSIONRATEER", "ER", "EROSIONRATE") ~ "F√≠sico",
# Biol√≥gico
Variavel_padrao %in% c("MICROBIALBIOMASSCARBONMBC", "MBC") ~ "Biol√≥gico",
Variavel_padrao %in% c("BASALRESPIRATIONBR", "BR") ~ "Biol√≥gico",
Variavel_padrao %in% c("MICROBIALQUOTIENTQMIC", "QMIC") ~ "Biol√≥gico",
Variavel_padrao %in% c("QCO2", "QCO") ~ "Biol√≥gico",  # <- ajuste aqui
# Outros
TRUE ~ "Outros"
)
)
# 8. Unir ao resumo, padronizar e gerar r√≥tulos √∫nicos
resumo_vars <- resumo_vars %>%
mutate(
Variavel = trimws(gsub("\t", " ", as.character(Variavel))),
Variavel_padrao = toupper(gsub("[^A-Za-z]", "", Variavel))
) %>%
left_join(mapa_grupos %>% select(Variavel_padrao, Grupo = Grupo_temp), by = "Variavel_padrao") %>%
mutate(
Grupo = factor(Grupo, levels = c("F√≠sico", "Qu√≠mico", "Biol√≥gico", "Outros")),
Variavel_ord = fct_inorder(Variavel)
) %>%
group_by(Variavel_ord) %>%
mutate(
studlab = paste0(Variavel_ord, " (n = ", N_estudos, ", obs = ", N_obs, ")"),
studlab = ifelse(n() > 1, paste0(studlab, " [", row_number(), "]"), studlab)
) %>%
ungroup()
rm(list = ls()); gc()
# 0. Carregar pacotes
library(readxl)
library(dplyr)
library(mice)
library(meta)
library(tibble)
library(future.apply)
library(purrr)
library(kableExtra)
library(ggplot2)
library(forcats)
rm(list = ls()); gc()
# 1. Ler base de dados
dados <- read_excel("C:/Users/vidal/OneDrive/Documentos/ARTIGO_MA/3 - DADOS/bd.xlsx", sheet = "MANEJO") %>%
mutate(across(c(m_e, sd_e, n_e, m_c, sd_c, n_c), ~ as.numeric(gsub(",", ".", gsub("[^0-9,.-]", "", as.character(.))))),
Variavel = factor(Variavel))
# 2. Imputa√ß√£o m√∫ltipla via CART
dados_imput <- mice(dados, m = 5, method = "cart", seed = 10)
# 3. Calcular lnRR e vari√¢ncia
dados_completos <- complete(dados_imput, action = "long", include = TRUE) %>%
filter(m_e > 0, m_c > 0) %>%
mutate(
lnRR = log(m_e / m_c),
vi = (sd_e^2 / (n_e * m_e^2)) + (sd_c^2 / (n_c * m_c^2))
) %>%
filter(!is.na(vi), !is.infinite(vi), vi > 0, vi < quantile(vi, 0.999, na.rm = TRUE))
# 4. Meta-an√°lises por imputa√ß√£o
resultados_rubin <- future_lapply(1:5, function(i) {
dados_i <- complete(dados_imput, i)
if (!"Variavel" %in% names(dados_i)) return(NULL)
var_levels <- unique(dados_i$Variavel)
map_dfr(var_levels, function(v) {
df <- filter(dados_i, Variavel == v)
if (nrow(df) == 0) return(NULL)
meta <- tryCatch(
metacont(
n.e = n_e, mean.e = m_e, sd.e = sd_e,
n.c = n_c, mean.c = m_c, sd.c = sd_c,
studlab = Study, sm = "SMD", method.smd = "Hedges",
method.tau = "REML", common = FALSE, data = df
),
error = function(e) NULL
)
if (is.null(meta)) return(NULL)
tibble(
.imp = i,
Variavel = v,
TE = meta$TE.random,
seTE = meta$seTE.random
)
})
}) %>% bind_rows()
# 5. Contagem de estudos
n_estudos_obs <- dados_completos %>%
group_by(Variavel) %>%
summarise(N_estudos = n_distinct(Study), N_obs = n(), .groups = "drop")
# 6. Combina√ß√£o por Rubin
resumo_vars <- resultados_rubin %>%
group_by(Variavel) %>%
summarise(
TE = mean(TE, na.rm = TRUE),
W = mean(seTE^2, na.rm = TRUE),
B = var(TE, na.rm = TRUE),
T_var = ifelse(is.na(B), W, W + (1 + 1/5) * B),
seTE = sqrt(T_var),
df = ifelse(is.na(B) || B == 0, Inf, (5 - 1) * (1 + W / ((1 + 1/5) * B))^2),
IC_inf = TE - qt(0.975, df) * seTE,
IC_sup = TE + qt(0.975, df) * seTE,
p_value = ifelse(is.infinite(df), 2 * pnorm(-abs(TE / seTE)), 2 * pt(-abs(TE / seTE), df)),
.groups = "drop"
) %>%
left_join(n_estudos_obs, by = "Variavel")
# 7. Classifica√ß√£o das vari√°veis por grupo funcional
mapa_grupos <- tibble(
Variavel_original = unique(as.character(resumo_vars$Variavel))
) %>%
mutate(
Variavel_padrao = toupper(gsub("[^A-Za-z]", "", Variavel_original)),
Grupo_temp = case_when(
# Qu√≠mico
Variavel_padrao %in% c("SOILORGANICCARBONSOC", "SOC") ~ "Qu√≠mico",
Variavel_padrao %in% c("SOILPH", "PH") ~ "Qu√≠mico",
Variavel_padrao %in% c("TOTALNITROGENTN", "TN") ~ "Qu√≠mico",
Variavel_padrao %in% c("AVAILABLETOTALPHOSPHORUSATP", "ATP") ~ "Qu√≠mico",
Variavel_padrao %in% c("AVAILABLEPOTASSIUMAK", "AK") ~ "Qu√≠mico",
Variavel_padrao %in% c("AVAILABLEMAGNESIUMAMG", "AMG") ~ "Qu√≠mico",
# F√≠sico
Variavel_padrao %in% c("SOILBULKDENSITYPB", "SOILBULKDENSITY", "BULKDENSITY", "PB") ~ "F√≠sico",
Variavel_padrao %in% c("PLANTAVAILABLEWATERCAPACITYPAWC", "PAWC") ~ "F√≠sico",
Variavel_padrao %in% c("MACROPOROSITYEMACRO", "MACROPOROSITYMACRO", "EMACRO") ~ "F√≠sico",
Variavel_padrao %in% c("PENETRATIONRESISTANCEPR", "PR") ~ "F√≠sico",
Variavel_padrao %in% c("WATERSTABLEAGGREGATESWSA", "WSA") ~ "F√≠sico",
Variavel_padrao %in% c("RUNOFFQ", "Q") ~ "F√≠sico",
Variavel_padrao %in% c("EROSIONRATEER", "ER", "EROSIONRATE") ~ "F√≠sico",
# Biol√≥gico
Variavel_padrao %in% c("MICROBIALBIOMASSCARBONMBC", "MBC") ~ "Biol√≥gico",
Variavel_padrao %in% c("BASALRESPIRATIONBR", "BR") ~ "Biol√≥gico",
Variavel_padrao %in% c("MICROBIALQUOTIENTQMIC", "QMIC") ~ "Biol√≥gico",
Variavel_padrao %in% c("QCO2", "QCO") ~ "Biol√≥gico",  # <- ajuste aqui
# Outros
TRUE ~ "Outros"
)
)
# 8. Unir ao resumo, padronizar e gerar r√≥tulos √∫nicos
resumo_vars <- resumo_vars %>%
mutate(
Variavel = trimws(gsub("\t", " ", as.character(Variavel))),
Variavel_padrao = toupper(gsub("[^A-Za-z]", "", Variavel))
) %>%
left_join(mapa_grupos %>% select(Variavel_padrao, Grupo = Grupo_temp), by = "Variavel_padrao") %>%
mutate(
Grupo = factor(Grupo, levels = c("F√≠sico", "Qu√≠mico", "Biol√≥gico", "Outros")),
Variavel_ord = fct_inorder(Variavel)
) %>%
group_by(Variavel_ord) %>%
mutate(
studlab = paste0(Variavel_ord, " (n = ", N_estudos, ", obs = ", N_obs, ")"),
studlab = ifelse(n() > 1, paste0(studlab, " [", row_number(), "]"), studlab)
) %>%
ungroup()
# 9. Criar metagen com r√≥tulos √∫nicos
meta_final <- metagen(
TE = resumo_vars$TE,
seTE = resumo_vars$seTE,
studlab = resumo_vars$studlab,
sm = "LogROM (lnRR)",
method.tau = "DL",
common = FALSE,
random = TRUE
)
# Criar vetor de cores com base nos grupos
cores_por_grupo <- c("F√≠sico" = "#0072B2", "Qu√≠mico" = "#009E73", "Biol√≥gico" = "#D55E00", "Outros" = "#0072B2")
# Vetor de cores para cada vari√°vel (ordem igual √† de resumo_vars)
cores_variaveis <- cores_por_grupo[as.character(resumo_vars$Grupo)]
# Forestplot com cores por grupo
forest(
meta_final,
comb.fixed = FALSE,
comb.random = TRUE,
overall = TRUE,
print.heterogeneity = FALSE,
print.Q = FALSE,
print.I2 = FALSE,
print.tau2 = FALSE,
col.square = cores_variaveis,
col.diamond = "black",
digits = 3,
digits.TE = 3,
atransf = exp,
at = seq(-0.6, 0.6, by = 0.2),
xlab = "SMD (Hedges)",
rightcols = c("effect", "ci", "w.random", "pval"),
rightlabs = c("Hedges", "IC 95%", "Peso (%)", "p-valor"),
leftcols = c("studlab"),
leftlabs = c("Indicadores funcionais")
)
# 11. Gr√°fico com ggplot2
ggplot(resumo_vars, aes(x = TE, y = Variavel_ord, fill = Grupo, shape = Grupo)) +
geom_point(size = 4, color = "black", stroke = 1.1) +
geom_errorbarh(aes(xmin = IC_inf, xmax = IC_sup), height = 0.2, color = "gray30") +
geom_vline(xintercept = 0, linetype = "dashed", color = "gray30") +
scale_fill_manual(values = c("F√≠sico" = "#0072B2", "Qu√≠mico" = "#009E73", "Biol√≥gico" = "#D55E00", "Outros" = "gray60")) +
scale_shape_manual(values = c("F√≠sico" = 21, "Qu√≠mico" = 22, "Biol√≥gico" = 24, "Outros" = 23)) +
labs(
title = "Forestplot por tipo de indicador funcional",
x = "Log Response Ratio (lnRR)",
y = "Indicadores funcionais",
fill = "Grupo funcional",
shape = "Grupo funcional"
) +
theme_minimal(base_size = 12) +
theme(
legend.position = "top",
panel.grid.major.y = element_blank(),
axis.text.y = element_text(size = 10)
)
# Supprimir avisos
options(warn = -1)
# Configurar CRAN mirror
options(repos = c(CRAN = "https://cran.rstudio.com"))
# Verificar e instalar pacotes necess√°rios
pacotes_necessarios <- c("PRISMA2020", "DiagrammeR", "htmlwidgets")
for (pacote in pacotes_necessarios) {
if (!require(pacote, character.only = TRUE)) {
cat(sprintf("üì¶ Instalando pacote: %s\n", pacote))
if (pacote == "PRISMA2020") {
# Instalar do GitHub
if (!require("devtools", character.only = TRUE)) {
install.packages("devtools", quiet = TRUE)
}
devtools::install_github("prisma-flowdiagram/PRISMA2020", quiet = TRUE)
} else {
install.packages(pacote, quiet = TRUE)
}
}
}
# Ler os dados
data <- read.csv(csv_file, stringsAsFactors = FALSE)
cat("‚úÖ Dados carregados com sucesso\n\n")
# Processar dados para formato correto
cat("üìä Processando dados PRISMA...\n")
prisma_data <- PRISMA_data(data)
# Gerar o fluxograma PRISMA 2020
cat("üé® Gerando fluxograma PRISMA 2020...\n")
plot <- PRISMA_flowdiagram(
prisma_data,
fontsize = 12,
font = "Helvetica",
title_colour = "Goldenrod1",
greybox_colour = "Gainsboro",
main_colour = "Black",
arrow_colour = "Black",
arrow_head = "normal",
arrow_tail = "none",
interactive = TRUE,
previous = FALSE,
other = TRUE,
detail_databases = TRUE,
detail_registers = FALSE,
meta_analysis = FALSE,
side_boxes = TRUE
)
# Salvar em diferentes formatos
output_html <- "prisma_flowdiagram_interativo.html"
output_pdf <- "prisma_flowdiagram.pdf"
output_png <- "prisma_flowdiagram.png"
output_svg <- "prisma_flowdiagram.svg"
cat("\nüì• Salvando arquivos...\n")
# HTML (com interatividade)
tryCatch({
PRISMA_save(plot, filename = output_html, filetype = "HTML", overwrite = TRUE)
cat(sprintf("‚úÖ HTML: %s\n", output_html))
}, error = function(e) {
cat(sprintf("‚ùå Erro ao salvar HTML: %s\n", e$message))
})
setwd("~/13 - CLONEGIT/revisaoescopo/2-DADOS/scripts")
# Supprimir avisos
options(warn = -1)
# Configurar CRAN mirror
options(repos = c(CRAN = "https://cran.rstudio.com"))
# Verificar e instalar pacotes necess√°rios
pacotes_necessarios <- c("PRISMA2020", "DiagrammeR", "htmlwidgets")
for (pacote in pacotes_necessarios) {
if (!require(pacote, character.only = TRUE)) {
cat(sprintf("üì¶ Instalando pacote: %s\n", pacote))
if (pacote == "PRISMA2020") {
# Instalar do GitHub
if (!require("devtools", character.only = TRUE)) {
install.packages("devtools", quiet = TRUE)
}
devtools::install_github("prisma-flowdiagram/PRISMA2020", quiet = TRUE)
} else {
install.packages(pacote, quiet = TRUE)
}
}
}
install.packages("devtools", quiet = TRUE)
library(PRISMA2020, quietly = TRUE)
library(htmlwidgets, quietly = TRUE)
library(DiagrammeR, quietly = TRUE)
# Verificar e instalar pacotes necess√°rios
pacotes_necessarios <- c("PRISMA2020", "DiagrammeR", "htmlwidgets")
for (pacote in pacotes_necessarios) {
if (!require(pacote, character.only = TRUE)) {
cat(sprintf("üì¶ Instalando pacote: %s\n", pacote))
if (pacote == "PRISMA2020") {
# Instalar do GitHub
if (!require("devtools", character.only = TRUE)) {
install.packages("devtools", quiet = TRUE)
}
devtools::install_github("prisma-flowdiagram/PRISMA2020", quiet = TRUE)
} else {
install.packages(pacote, quiet = TRUE)
}
}
}
library(PRISMA2020, quietly = TRUE)
library(htmlwidgets, quietly = TRUE)
library(DiagrammeR, quietly = TRUE)
install.packages("DiagrammeR")
install.packages("htmlwidgets")
library(PRISMA2020, quietly = TRUE)
library(htmlwidgets, quietly = TRUE)
library(DiagrammeR, quietly = TRUE)
install.packages("magrittr")
library(PRISMA2020, quietly = TRUE)
library(htmlwidgets, quietly = TRUE)
library(DiagrammeR, quietly = TRUE)
# Carregar dados do CSV
cat("======================================================================\n")
cat("üîÑ GERADOR DE FLUXOGRAMA PRISMA 2020 - VERS√ÉO R OFICIAL\n")
cat("======================================================================\n\n")
csv_file <- "PRISMA.csv"
if (!file.exists(csv_file)) {
cat(sprintf("‚ùå Arquivo %s n√£o encontrado!\n", csv_file))
quit(status = 1)
}
if (!file.exists(csv_file)) {
cat(sprintf("‚ùå Arquivo %s n√£o encontrado!\n", csv_file))
quit(status = 1)
}
cat(sprintf("üìÇ Carregando dados de: %s\n", csv_file))
# Ler os dados
data <- read.csv(csv_file, stringsAsFactors = FALSE)
cat("‚úÖ Dados carregados com sucesso\n\n")
# Processar dados para formato correto
cat("üìä Processando dados PRISMA...\n")
prisma_data <- PRISMA_data(data)
